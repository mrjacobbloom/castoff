/**
 * CastOff - by Jacob Bloom - Updated Mar. 2023 - MuseScore 3-4 version
 *
 * How to use: After you've finished note entry and are ready to think about layout, enable this plugin. It'll
 * automagically (do its best to) fix all systems to 2, 4, or 8 measures. What's more, it stays on after that,
 * so you can start to add your own system or page breaks, and it'll continue to adjust the rest of the score
 * as you go! Basically, from that point on, you can treat it like a drop-in replacement for the built-in lay-
 * out system.
 *
 * A little explanation of how this works, because I know I'll be baffled by this code in 6 months: It's a state
 * machine that basically tackles layout in a few passes: gathering measure min-widths in Continuous View;
 * gathering system size in Page View, then actual layout. A couple hacks worth explaining:
 * - Measure min-widths are stored on the measure in the unused (but persistent, at least for the session?)
 *   measure.color.r channel. To fit in there, the widths are divided by 256 (not that any measure would hit
 *   the max width of 256sp but whatever). Also store a sentinel value in the green channel so we can re-
 *   start and be confident that we don't have to do the Continuous View thing again.
 * - In the layout pass, it adds LineBreak elements as needed. It marks them as plugin-generated by, again,
 *   abusing the unused color channel with a sentinel value. This means on subsequent layout passes it can
 *   clear its own layout stuff but preserve user-generated layout. Optionally, it places the LineBreaks off-
 *   screen so it feels more magical.
 * - To switch between page mode and continuous mode, it calls the poorly-documented cmd('viewmode')
 *   which SEEMS to toggle between (Horiz.) Continuous View and Page View... Some quick tests show that
 *   running cmd while already in VCV kicks you into PV, so there's logic to handle that case. But afaict, cmd
 *   will never move you into VCV. (Generally the plugin tbehaves the same between VCV and PV anyway.)
 * - The plugin makes every effort not to touch the undo stack (which is explicitly not recommended by the
 *   MS devs). As part of that, once layout is done, it forces the engraving canvas to re-render by toggling
 *   note-input mode twice, because there aren't any other commands that cause a re-render without
 *   actually modifying the score... Well, there's a declaration for a "relayout" command but it doesn't seem
 *   to actually work :((( The problem with toggling note-input is that it can cause scroll jumps if the high-
 *   lighted note is off-screen. Hopefully in the real world that won't be too big an issue
 */

import QtQuick 2.6
import QtQuick.Controls 2.2
import MuseScore 3.0

MuseScore {
      id: castoff;
      description: 'A drop-in replacement for MuseScore\'s layout engine that fixes all systems to 2, 4, or 8 measures.';
      version: '2.0';

      pluginType: 'dock';
      anchors.fill: parent;

      Component.onCompleted: {
            if (mscoreMajorVersion >= 4) {
                  castoff.title = 'CastOff';
                  castoff.categoryCode = 'composing-arranging-tools';
                  castoff.pluginType = 'dialog';
                  castoff.thumbnailName = 'logo.png';
            } else {
                  castoff.menuPath = 'Plugins.CastOff';
                  castoff.dockArea = 'left';
            }
      }

      /**
       * List of casting-off options available to the user, and their human-friendly names
       */
      property var castingOffOptions: [
            { value: [2, 1], text: '2 (or bail to 1)'  },
            { value: [4, 1], text: '4 (or bail to 1)'  },
            { value: [8, 1], text: '8 (or bail to 1)'  },
            { value: [16, 1], text: '16 (or bail to 1)'  },
            { value: [4, 2, 1], text: '4 or 2'  },
            { value: [8, 4, 2, 1], text: '8, 4 or 2' },
            { value: [16, 8, 4, 2, 1], text: '16, 8, 4 or 2' },
      ];
      property int defaultCastingOffIndex: 5; // Just to help everything initialize in sync
      
      /**
       * User configuration -- these didn't all actually get a UI but I still mentally lump them together.
       */
      property var config: ({
            /**
             * Attempt to fix the casting-off (measures per system) to each of these sizes, which should be ordered
             * largest to smallest (it'll always pick the largest that fits)
             * @type {number[]}
             */
            preferredCastingsOff: castingOffOptions[defaultCastingOffIndex].value,
            
            /**
             * Hide injected LineBreaks so user can tell UCSB apart from our injected layout stuff
             * @type {boolean}
             */
            hideLayoutModifiers: true,
            
            /**
             * Measures can be finnicky, we're fighting the builtin layout system, which /occasionally/ has strong opinions.
             * To make things easier, we multiply the detected system-width by this, lowering our expectations of how many
             * bars we can fit in a line, which makes them more likely to comply. (also worth noting: we set the "user stretch"
             * for each measure to a very low value)
             * @type {number}
             */
            wiggleRoomCoefficient: .75
      });

      /**
       * We want to respect manually-inserted LineBreaks. In order to track which LineBreaks were
       * inserted by the plugin, we use this sentinel value in the (unused but persistent?) color slot
       * on plugin-generated LineBreak elements
       * @type {string}
       */
      property color sentinel_color: '#800000FF';

      /**
       * Similarly, we want to detect if we've already collected measure min widths, which are stored in the red
       * channel of the measure's unused color slot. So we put this sentinel value in the green channel
       */
      property real sentinel_green: 0.75;

      /**
       * The API's scoreStateChanged will sometimes tell us where in the score a change occurred. Since our layout
       * algorithm works start-to-finish, we can take advantage of this to save ourselves some work. Musescore
       * apparently breaks up time into discrete units called ticks, so with a single integer you can jump to any place
       * in the score.
       * @type {number}
       */
      property int startLayoutTick: 0;

      /**
       * The width of the initial system and subsequent systems, in sp. This assumes all subsequent systems are the
       * same width, which isn't always true (trivially: SectionBreaks cause full instrument names to show again)
       * @type {number}
       */
      property real initialSystemWidth: 0;
      property real subsequentSystemWidth: 0;

      /**
       * Debounce layouts, we don't wanna do too many in a short time.
       */
      property int lastLayoutTime: -1;
      property int minTimeBetweenLayouts: 40; // Over 2 frames of 60fps animation thread
      
      /**
       * @typedef {number} CastOffState - the available states for the CastOff state machine
       */

      /**
       * Enum the possible states of the state machine.
       * @enum {CastOffState}
       */
      property var s: ({
            INITIAL: 0,
            STORING_MEASURE_MIN_WIDTHS: 1,
            STORING_SYSTEM_WIDTHS: 2,
            LAYOUT: 3,
            IDLE: 4,
      });

      /**
       * Current state of the state machine
       * @type {CastOffState}
       */
      property int currentState: s.INITIAL;

      onRun: {
            reverseStatesMap();
            executeState();
      }

      onScoreStateChanged: {
            // "state" variable here is NOT the CastOff state machine's currentState,
            // it's MuseScore-generated info about the score change
            if (state.undoRedo) return;

            if (currentState === s.IDLE) {
                  startLayoutTick = state.startLayoutTick;
                  executeState();
            }
      }

      ScrollView {
            anchors.fill: parent;

            Column {
                  spacing: 20;
                  padding: 20;
                  width: parent.parent.width - (2 * padding);

                  Text {
                        width: parent.width;
                        wrapMode: Text.Wrap;
                        textFormat: Text.StyledText;

                        // &nbsp;'s are because spaces after periods/commas aren't rendering on my machine.
                        // A quick google search makes me think it might be a macOS issue but I have't dug into it
                        text: 'Add line and page breaks as normal,&nbsp;we\'ll continue to work around you.<br/><br/>' +
                              'If you make changes to the content of the score,&nbsp;like adding/removing measures,&nbsp;' +
                              'or adding new notes,&nbsp;click <i>Content changed</i>.';
                  }

                  Column {
                        width: parent.width;

                        Label {
                              width: parent.width;
                              wrapMode: Text.WordWrap;
                              text: 'Measures per system:';
                              font.pointSize: 12;
                        }

                        ComboBox {
                              width: parent.width;
                              model: castingOffOptions.map(function(m) { return m.text; });
                              onActivated: {
                                    config.preferredCastingsOff = castingOffOptions[currentIndex].value;
                                    refreshLayout();
                              }

                              Component.onCompleted: {
                                    overrideButtonStyles(this);
                                    currentIndex = defaultCastingOffIndex;
                                    config.preferredCastingsOff = castingOffOptions[defaultCastingOffIndex].value;
                              }
                        }
                  }

                  CheckBox {
                        width: parent.width;
                        checked: !config.hideLayoutModifiers;
                        leftPadding: 0;
                        text:'Show generated layout';
                        onToggled: {
                              config.hideLayoutModifiers = !config.hideLayoutModifiers;
                              refreshLayout();
                        }

                        Component.onCompleted: { contentItem.wrapMode = Text.WordWrap; }
                  }

                  Button {
                        width: parent.width;
                        text: 'Content changed';
                        onClicked: {
                              invalidateStoredMeasureWidths();
                              enterState(s.INITIAL);
                        }

                        Component.onCompleted: overrideButtonStyles(this);
                  }
            
                  Button {
                        width: parent.width;
                        text: 'Reset layout and quit CastOff';
                        onClicked: {
                              resetMeasureColorsAndStretch();
                              removeGeneratedLineBreaks(curScore.firstMeasure);

                              // MuseScore 4 requires you to use a provided "quit" function, not available in 3.x
                              typeof quit === 'undefined' ? Qt.quit() : quit();
                        }

                        Component.onCompleted: overrideButtonStyles(this, 'darkred');
                  }

                  Text {
                        id: statusText;
                        width: parent.width;
                        textFormat: Text.StyledText;
                        wrapMode: Text.Wrap;
                        color: '#444'; // MuseScore has a dark mode, right? Should this adapt to that? Eh
                        text: ''
                  }
            }
      }
      
      /**
       * This Timer forces engraving to re-render after doLayout, so our changes are actually
       * shown to the user.
       */
      Timer {
            id: layoutTimer;
            interval: 20; // can't be faster than 60fps (~16ms)
            repeat: false;

            onTriggered: {
                  log('Forcing engraving re-render.');
                  // This can lead to scroll jumps, but there aren't many options that don't add to the undo stack :/
                  // There's a cmd declared called "relayout" but it doesn't seem to work :(
                  cmd('note-input'); 
                  cmd('note-input');
            }
      }
      
      /**
       * I don't like the default Qt button style but I don't wanna make a whole new component type or styling file so here's this
       * @param {QQuickButton} self
       * @param {color?} borderColor - color to use for the border
       * @returns {void}
       */
       function overrideButtonStyles(self, borderColor) {
            self.background.border.color = borderColor || '#bbb';
            self.background.border.width = 1;
            self.contentItem.wrapMode = Text.WordWrap;
       }

      /**
       * Switch to a given state and imediately execute it
       * @param {CastOffState} newState
       * @returns {void}
       */
      function enterState(newState) {
            log('State change: ' + currentState + ' ' + s[currentState] + ' -> ' + newState + ' ' + s[newState]);
            if (newState === undefined) log((new Error).stack);
            currentState = newState;
            executeState();
      }
      
      /**
       * Execute the current state of the state machine. If it's not clear, I'm trying really hard to remember the
       * normal way to do this stuff from college, and it's super not coming back to me so I made this all up (^.^')
       * @returns {void}
       */
      function executeState() {
            switch (currentState) {

                  case s.INITIAL: {
                        if (!isContinuous()) {
                              if (detectMeasureWidthsAlreadyStored()) {
                                    enterState(s.STORING_SYSTEM_WIDTHS);
                              } else {
                                    cmd('viewmode');
                                    // If we started in Vert. Cont. View, we're now in Page View
                                    // Afaict, cmd will never toggle to VCV, so we should be good from here.
                                    if (!isContinuous()) cmd('viewmode');
                                    enterState(s.STORING_MEASURE_MIN_WIDTHS);
                              }
                        } else {
                              enterState(s.STORING_MEASURE_MIN_WIDTHS);
                        }
                        break;
                  }

                  case s.STORING_MEASURE_MIN_WIDTHS: {
                        storeMeasureWidths();
                        cmd("viewmode");
                        enterState(s.STORING_SYSTEM_WIDTHS);
                        break;
                  }

                  case s.STORING_SYSTEM_WIDTHS: {
                        storeSystemWidths();
                        startLayoutTick = 0;
                        enterState(s.LAYOUT);
                        break;
                  }

                  case s.LAYOUT: {
                        // Debounce layout operations, especially to avoid infinite recursion
                        if (Date.now() - lastLayoutTime < minTimeBetweenLayouts) {
                              startLayoutTick = -1;
                              enterState(s.IDLE);
                        } else if (isContinuous()) {
                              setStatusText('Paused while in Continuous View.');
                              startLayoutTick = -1;
                              enterState(s.IDLE);
                        } else {
                              doLayout();
                              lastLayoutTime = Date.now();
                              startLayoutTick = -1;
                              enterState(s.IDLE);
                        }
                        break;
                  }

                  case s.IDLE: {
                        if (startLayoutTick !== -1) {
                              enterState(s.LAYOUT);
                        }
                        break;
                  }

                  default: {
                        log('State machine encountered unexpected state ' + currentState);
                 }
            }
      }
      
      /**
       * Make it so key 0 points to 'INITIAL' as well in the states enum object, etc. (for logging)
       * @returns {void}
       */
      function reverseStatesMap() {
            const keys = Object.keys(s);
            for (var i = 0; i < keys.length; i++) {
                  const key = keys[i];
                  s[s[key]] = key;
            }
      }
      
      /**
       * After the user changes a setting that affects layout, re-run the layout algorithm.
       * @returns {void}
       */
      function refreshLayout() {
            startLayoutTick = 0;
            executeState();
      }

      /**
       * Change the message displayed to the user in the window
       * @param {string} message
       * @returns {void}
       */
      function setStatusText(message) {
            statusText.text = 'Status:&nbsp;<i>' + message + '</i>';
      }
      
      /**
       * Scoped wrapper for console.log (and make it easy to disable logging if needed)
       * @param {string} message
       * @returns {void}
       */
      function log(message) {
            console.log('CastOff: ' + message);
      }

      /**
       * Rewind the given cursor to the first measure in its system. Note that the Plugin API doesn't have much of a
       * concept of systems, so we do this by tracking changes in position/page number between sibling measures.
       * @param {Cursor} cursor - the cursor to rewind
       * @returns {void}
       */
      function rewindToFirstMeasureInSystem (cursor) {
            var measure = cursor.measure;
            var originalX = measure.pagePos.x;
            var originalY = measure.pagePos.y;
            var originalPageNumber = measure.parent.parent.pagenumber;
            while (true) {
                  const prevMeasure = measure.prevMeasureMM;
                  if (!prevMeasure) break;
                  if (prevMeasure.pagePos.x >= originalX) break;
                  if (prevMeasure.pagePos.y !== originalY) break;
                  if (prevMeasure.parent.parent.pagenumber !== originalPageNumber) break;
                  measure = prevMeasure;
            }
            cursor.rewindToTick(measure.firstSegment.tick)
      }
      
      /**
       * Whether the measure has a user-created layout-break element of any kind
       * @param {Measure} measure - measure
       * @returns {boolean}
       */
      function hasUserCreatedSystemBreak (measure) {
            if (!measure) return false;
            for (var i = 0; i < measure.elements.length; i++) {
                  const element = measure.elements[i];
                  if (element.type === Element.LAYOUT_BREAK && !element.isNoBreak) {
                        return true;
                  }
            }
            return false;
      }
      
      /**
       * Remove plugin-generated LineBreaks (leaving user-created ones) starting with the given measure
       * @param {Measure} startMeasure - measure to start removing at
       * @returns {void}
       */
      function removeGeneratedLineBreaks (startMeasure) {
            const measure = startMeasure;
            do {
                  for (var i = 0; i < measure.elements.length; i++) {
                        const element = measure.elements[i];
                        if (element.type === Element.LAYOUT_BREAK && Qt.colorEqual(element.color, sentinel_color)) {
                              removeElement(element);
                        }
                  }
                  console.log('MEASURE', JSON.stringify(measure));
            } while (measure = measure.nextMeasure);
      }
      
      /**
       * Generates and inserts a LineBreak, which is marked with sentinel_color so the plugin can tell
       * it apart from user-generated ones.
       * @param {Cursor} cursor
       * @returns {void}
       */
      function insertLineBreak (cursor) {
            var lb = newElement(Element.LAYOUT_BREAK);
            lb.layoutBreakType = LayoutBreak.LINE;
            lb.color = sentinel_color;
            if (config.hideLayoutModifiers) {
                  lb.offsetY = -10 - cursor.measure.pagePos.y; // Hide it just above the page
                  lb.offsetX = 20; // Less nasty when you switch to "single page" mode
            }
            cursor.add(lb);
      }
      
      /**
       * Information about whether a given number of measures fits inside a system, like what tick it'd end on.
       * eof=true if the final measure is encountered. encounteredUCSB=true if a user-created section break is encountered.
       * @typedef {{ fits: boolean; encounteredUCSB?: true; lastMeasureTick: number; eof?: true }} FitCheckResult
       */
      
      /**
       * Determine if N measures fit inside a system. Note that this function may return special values if it
       * encounters special cases (see above typedef)
       * @param {Measure} firstMeasure
       * @param {number} castingOff - number of measures to attempt to fit into the system
       * @param {number} systemWidth - maximum system width (in sp units)
       * @returns {FitCheckResult}
       */
      function fitCheck (firstMeasure, castingOff, systemWidth) {
            var totalWidth = 0;
            var measure = firstMeasure;
            for (var i = 1; i < castingOff; i++) {
                  if (!measure) return { eof: true }
                  totalWidth += getMinWidth(measure);
                  if (hasUserCreatedSystemBreak(measure) && totalWidth <= systemWidth) {
                        // User has manually added layout elements, bail and defer to them.
                        return { encounteredUCSB: true, lastMeasureTick: measure.firstSegment.tick } ;
                  }
                  measure = measure.nextMeasureMM;
            }
            if (!measure) return { eof: true };
            return { fits: totalWidth <= systemWidth, lastMeasureTick: measure.firstSegment.tick, castingOff: castingOff};
      }
      
      /**
       * Run fitCheck with each preferredCastingOff and return the largest fit, or the first to run into a special case.
       * @param {Measure} firstMeasure
       * @param {number} systemWidth - maximum system width (in sp units)
       * @returns {FitCheckResult}
       */
      function findBestFit(firstMeasure, systemWidth) {
            for (var i = 0; i < config.preferredCastingsOff.length; i++) {
                  var possibleCastOff = config.preferredCastingsOff[i];
                  var result = fitCheck(firstMeasure, possibleCastOff, systemWidth);
                  if (result.eof) return result;
                  if (result.encounteredUCSB) return result;
                  if (result.fits) return result;
            }
      }
      
      /**
       * Main loop of the layout step. Start the layout process at the location of startLayoutTick
       * @returns {void}
       */
      function doLayout () {
            var cursor = curScore.newCursor();
            cursor.rewindToTick(startLayoutTick || 0);
            if (!cursor.measure) return;
            rewindToFirstMeasureInSystem(cursor)
            
            const pageNum = cursor.measure.parent.parent.pagenumber + curScore.pageNumberOffset;
            setStatusText('Last layout from page ' + pageNum + ' at ' + (new Date).toTimeString() + '.');
            

            removeGeneratedLineBreaks(cursor.measure);
            var isFirstSystem = cursor.tick === 0;
            while (cursor.measure) {
                  var systemWidth = isFirstSystem ? initialSystemWidth : subsequentSystemWidth;
                  const result = findBestFit(cursor.measure, systemWidth * config.wiggleRoomCoefficient);
                  // log('doLayout ' + JSON.stringify(result));
                  if (result.eof) {
                        break;
                  } else if (result.encounteredUCSB) {
                        cursor.rewindToTick(result.lastMeasureTick);
                        cursor.nextMeasure();
                  } else {
                        cursor.rewindToTick(result.lastMeasureTick);
                        insertLineBreak(cursor);
                        cursor.nextMeasure();
                  }
                  isFirstSystem = false;
            }

            layoutTimer.start();
      }
      
      /**
       * Store the width of initial system and subsequent systems
       * @returns {void} -- this function is all side effects baybeeeee
       */
      function storeSystemWidths() {
            var measure = curScore.firstMeasure;
            initialSystemWidth = measure.parent.bbox.width - measure.posX;

            var prevX = -1;
            do {
                  if (!measure) return; // EOF, i.e. there's only 1 system... I guess...
                  if (measure.pagePos.x <= prevX || measure.parent.parent.pagenumber > 0) {
                        subsequentSystemWidth = measure.parent.bbox.width - measure.posX;
                        return;
                  }
                  prevX = measure.pagePos.x;
            } while (measure = measure.nextMeasureMM);
      }
      
      function resetMeasureColorsAndStretch() {
            var cursor = curScore.newCursor();
            cursor.rewind(Cursor.SCORE_START);
            do {
                  cursor.measure.color = 'black';
                  cursor.measure.userStretch = 1;
            } while (cursor.nextMeasure());
      }
      
      /*
       * Make detectMeasureWidthsAlreadyStored return false, so we can re-grab measure widths
       * @returns {void}
       */
      function invalidateStoredMeasureWidths() {
            var cursor = curScore.newCursor();
            cursor.rewind(Cursor.SCORE_START);
            cursor.measure.color.g = 0;
      }
      
      /**
       * If on load the measure widths have already been detected, we can skip that whole step
       * @returns {boolean}
       */
      function detectMeasureWidthsAlreadyStored() {
      return false;
            var cursor = curScore.newCursor();
            cursor.rewind(Cursor.SCORE_START);
            do {
                  // Check the distance between the g channel and sentinel value, since using === w/ floats is flaky.
                  // I was hoping I wouldn't have to do this, since this number can be stored perfectly as hex, Ah well
                  if (Math.abs(cursor.measure.color.g - sentinel_green) > .01) return false;
            } while (cursor.nextMeasure());
            return true;
      }
      
      /**
       * Crawl through the score, and store the width of each measure (in sp) in its color.r channel (div'd by 256).
       * Fun surprise side-effect: it also sets the measure stretch to the minimum, making the measure more likely to
       * do what we want.
       * @returns {void}
       */
      function storeMeasureWidths() {
            var cursor = curScore.newCursor();
            cursor.rewind(Cursor.SCORE_START);
            do {
                  cursor.measure.color.r = Math.min(cursor.measure.bbox.width / 256, 1);
                  cursor.measure.color.g = sentinel_green;
                  cursor.measure.userStretch = .3;
            } while (cursor.nextMeasure());
      }
      
      /**
       * Helper to get minWidth data out of a measure, since I'll definitely forget to multiply by 256.
       * @param {Measure}
       * @returns {number} - measure's min width in sp units
       */
      function getMinWidth(measure) {
            return measure.color.r * 256;
      }
      
      /**
       * Make a best guess about (horizontal) continuous mode. This may fail for extreme cases like pieces with very
       * few measures, pieces that are entirely multimeasure rests, or ridiculous layout settings. But if your score
       * looks like that, this plugin wouldn't work very well anyway.
       * @retuens {boolean}
       */
      function isContinuous() {
            return curScore.lastMeasure.parent.parent.pagenumber === 0
            && (curScore.firstMeasure.pagePos.y === curScore.lastMeasure.pagePos.y);
      }
}